# 项目实施计划

- **文档版本**: 1.0
- **更新日期**: 2025-11-04
- **关联文档**: [需求文档](./需求文档.md), [系统设计文档](./系统设计文档.md)

---

## 概述

本计划将整个开发过程分解为 5 个按优先级排序的主要步骤。我们将一次专注于一个步骤，确保每个部分都稳固之后再进行下一步，以实现迭代开发和风险控制。

---

## 实施步骤

### **步骤 1: 环境搭建与基础骨架 (Foundation Setup)**
- **任务**:
    1.  初始化项目，创建 `git` 仓库和 `.gitignore` 文件。
    2.  创建项目目录结构 (`src/`, `curriculum/`)。
    3.  创建 `requirements.txt` 并添加核心依赖 (`langchain`, `langgraph`, `langchain-google-genai`, `python-dotenv`, `langchain_sqlite`)。
    4.  创建 `.env.template` 文件，用于指导用户配置 `GOOGLE_API_KEY` 和 `TELEGRAM_BOT_TOKEN`。
    5.  在 `src/` 目录下创建空的 `state.py`, `tools.py`, `nodes.py`, `graph.py`, `bot.py` 文件。
    6.  创建 `curriculum/framework.md` 并填入一个简单的占位符内容。
- **目标**: 确保开发环境一致，项目结构就位。

### **步骤 2: 核心图逻辑实现 (Core Graph Logic)**
- **任务**:
    1.  在 `state.py` 中完整定义 `CourseGenerationState`。
    2.  在 `tools.py` 中实现 `load_curriculum_framework()` 函数。
    3.  在 `nodes.py` 中实现**非 LLM 调用**的节点：`load_framework` 和 `finalize_content`。
    4.  在 `nodes.py` 中实现**调用 LLM** 的节点：`generate_initial_draft` 和 `revise_draft`，并编写相应的 Prompts。
    5.  在 `graph.py` 中组装这些节点，并定义课程审核的条件边 `route_content_feedback`。
- **目标**: 拥有一个可以在内存中运行、能够根据反馈进行内容生成和修改的核心工作流。此阶段可以先在本地进行测试，无需连接 Bot。

### **步骤 3: Telegram Bot 集成 (Bot Integration)**
- **任务**:
    1.  在 `bot.py` 中，使用 `python-telegram-bot` 设置基础的 Bot。
    2.  实现 `/start` 命令处理器，该处理器负责为每个用户会话生成一个唯一的 `thread_id`。
    3.  将在 `graph.py` 中编译好的 `app` 导入 `bot.py`。
    4.  实现消息处理器，将用户的输入作为 `user_feedback` 传递给 `app.invoke()`，并传入对应的 `thread_id`。
    5.  将 LangGraph 返回的结果（如课程草稿）发送回给用户。
- **目标**: 将核心工作流与用户接口连接起来，实现端到端的交互。

### **步骤 4: 网页生成与部署 (Web Generation & Deployment)**
- **任务**:
    1.  在 `nodes.py` 中实现 `generate_webpage` 节点，编写一个能将课程 Markdown 转换为 HTML 的 Prompt。
    2.  在 `tools.py` 中实现 `deploy_webpage` 函数的**模拟版本**（例如，打印 HTML 内容并返回一个假的 URL）。
    3.  在 `nodes.py` 中实现 `deploy_webpage` 节点，它调用 `tools.deploy_webpage`。
    4.  在 `graph.py` 中将新节点和相关的边（包括网页审核循环）添加到图中。
- **目标**: 扩展图的功能，使其能够完成从内容生成到网页部署的完整流程（部署部分暂时是模拟的）。

### **步骤 5: 持久化与收尾 (Persistence & Final Touches)**
- **任务**:
    1.  在 `graph.py` 中，配置 `SqliteSaver` 作为检查点，并将其绑定到编译好的 `app` 上。
    2.  在 `bot.py` 中，确保每次调用 `app.invoke()` 时都正确传递 `thread_id`，以利用持久化能力。
    3.  进行端到端的完整测试，包括中断 Bot、重启服务，然后再次对话，验证流程是否能从上次中断的地方正确恢复。
    4.  完善 `README.md`，添加项目介绍、安装和运行指南。
- **目标**: 确保系统满足“可靠性”的非功能性需求，并完成项目文档。
