# 系统设计文档：英语课程自动化 Agent

- **文档版本**: 1.0
- **更新日期**: 2025-10-31
- **关联需求**: [需求文档 v1.0](./需求文档.md)

---

### **目录**
1.  [系统评估与技术选型](#1-系统评估与技术选型)
2.  [系统设计与架构](#2-系统设计与架构)
3.  [详细技术方案](#3-详细技术方案)

---

### **1. 系统评估与技术选型**

#### **1.1. 核心挑战分析**
需求的本质不是一个简单的“提问-回答”或“工具调用”的线性任务，而是一个**有明确阶段、需要暂停、等待人类反馈、并根据反馈决定下一步走向的业务流程（Workflow）**。

关键特性包括：
1.  **人类在环（Human-in-the-Loop）**: 流程中存在两个明确的“断点”（课程审核、网页审核），Agent 必须暂停并等待外部输入才能继续。
2.  **状态管理（State Management）**: 流程是长周期的、有状态的。Agent 需要清晰地追踪当前处于哪个阶段、草稿是第几版、最终内容是什么等。
3.  **确定性的流程（Deterministic Flow）**: 业务流程的路径是明确的。课程审核通过后，**必然**进入网页制作环节；网页审核不通过，**必然**回到修改网页的步骤。

#### **1.2. 技术选型：LangChain vs. LangGraph**
- **LangChain Agent**: 其设计初衷是自主运行的“思考-行动”循环。让它停下来等待一个可能是几小时后的外部消息，实现起来会非常笨拙。其状态管理对于多阶段的复杂流程也容易变得混乱。
- **LangGraph**: 它的核心设计就是为了解决上述挑战。
    - **中断（Interrupt）机制**：可以轻松地在任何节点后暂停图的执行。
    - **显式的状态对象（State Object）**：完美管理流程中需要追踪的所有信息。
    - **代码定义的边（Edges）**：可以用代码来定义确定的、不可更改的流程规则，保证了流程的可靠性。

#### **1.3. 结论**
**本项目 100% 应使用 LangGraph**。它并非仅仅是“更适合”，而是“为此而生”的正确工具。

---

### **2. 系统设计与架构**

#### **2.1. 整体架构**
系统分为三个主要部分：

1.  **接口层 (Interface)**:
    *   **Telegram Bot**: 负责接收用户的消息，并将其传递给后端的 LangGraph 应用。同时，它也负责将 Agent 的回复、审核请求和最终链接展示给用户。

2.  **编排层 (Orchestrator)**:
    *   **LangGraph 应用**: 整个系统的大脑。它定义了课程创建的完整工作流。每一个用户的课程请求都会创建一个独立的、可持久化的图（Graph）实例来管理其状态。

3.  **执行层 (Execution)**:
    *   **LLM 模型**: 用于生成和修改课程内容、生成网页代码。
    - **工具 (Tools)**:
        - `curriculum_loader`: 一个简单的函数，用于读取固定的课程设计框架文档。
        - `web_deployer`: 一个执行服务器部署命令的函数（例如通过 `ssh` 和 `scp`，或调用 Vercel/Netlify 的 API）。

#### **2.2. 核心编排层：LangGraph 设计**

##### **2.2.1. 状态 (State)**
我们定义一个 `TypedDict` 来管理整个流程的状态，这确保了类型安全和数据流的清晰。

```python
from typing import List, TypedDict, Annotated
from langchain_core.messages import BaseMessage
from langgraph.graph.message import add_messages

class CourseGenerationState(TypedDict):
    # 输入信息
    theme: str                 # 今天的课程主题
    user_feedback: str         # 用户的反馈
    
    # 核心内容
    curriculum_framework: str  # 固定的课程框架内容
    lesson_draft: str          # 当前的课程草稿
    final_lesson_content: str  # 最终确认的课程内容
    
    # 网页和部署
    webpage_html: str          # 生成的网页HTML代码
    deployment_url: str        # 部署后的访问链接
    
    # 专门用于和LLM交互的消息历史
    messages: Annotated[List[BaseMessage], add_messages]
```
> **注**: `messages` 字段使用 `Annotated` 和 `add_messages` 是 LangGraph 中处理对话历史的标准方法，可以自动将新消息追加到列表中，而不是覆盖。

##### **2.2.2. 节点 (Nodes)**
每个节点都是一个 Python 函数，它接收当前状态作为输入，并返回一个包含状态更新的字典。

- `load_framework(state)`: 读取本地课程框架文档，更新 `curriculum_framework`。
- `generate_initial_draft(state)`: 调用 LLM 生成第一版课程，更新 `lesson_draft`。
- `revise_draft(state)`: 根据 `user_feedback` 调用 LLM 修改课程，更新 `lesson_draft`。
- `finalize_content(state)`: 将 `lesson_draft` 同步到 `final_lesson_content`。
- `generate_webpage(state)`: 调用 LLM 生成 HTML，更新 `webpage_html`。
- `deploy_webpage(state)`: 执行部署脚本，更新 `deployment_url`。

##### **2.2.3. 流程 (Edges & Control Flow)**
使用 `StateGraph` API 来构建图，定义节点间的连接和循环逻辑。

```python
from langgraph.graph import StateGraph, END

# 1. 初始化图并绑定状态
workflow = StateGraph(CourseGenerationState)

# 2. 添加所有节点
workflow.add_node("load_framework", load_framework)
# ... (add other nodes) ...
workflow.add_node("deploy_webpage", deploy_webpage)

# 3. 设置图的入口和固定路径
workflow.set_entry_point("load_framework")
workflow.add_edge("load_framework", "generate_initial_draft")
workflow.add_edge("finalize_content", "generate_webpage")
workflow.add_edge("generate_webpage", "deploy_webpage")

# 4. 定义课程内容审核循环
def route_content_feedback(state: CourseGenerationState):
    if "approve" in state["user_feedback"].lower():
        return "finalize_content"
    return "revise_draft"

workflow.add_conditional_edges("generate_initial_draft", route_content_feedback)
workflow.add_conditional_edges("revise_draft", route_content_feedback)

# 5. 定义网页审核循环
def route_webpage_feedback(state: CourseGenerationState):
    if "approve" in state["user_feedback"].lower():
        return END # 流程结束
    return "generate_webpage" # 重新生成网页

workflow.add_conditional_edges("deploy_webpage", route_webpage_feedback)

# 6. 编译图
app = workflow.compile()
```

#### **2.3. 接口层：Telegram Bot 集成**

1.  **启动流程**: 用户输入 `/start <课程主题>`，Bot 服务调用 `app.invoke` 启动一个新的图实例。
2.  **处理中断与持久化**: 使用 LangGraph 的**检查点（Checkpointer）**机制，图在每一步执行后都会自动保存状态。当流程需要用户输入时（如 `generate_initial_draft` 后），执行自然暂停。Bot 服务从检查点读取最新状态，将审核内容（如 `lesson_draft`）发送给用户。
3.  **继续流程**: 用户回复的消息被捕获，更新到状态的 `user_feedback` 字段中。Bot 服务再次调用 `app.invoke`，LangGraph 会从上次中断的地方继续执行，并进入相应的条件路由。
4.  **结束流程**: 当图执行到 `END` 节点，流程完成，Bot 发送最终通知。

---

### **3. 详细技术方案**

本节将系统设计文档中的高级概念具体化为可执行的技术规格和代码结构。

#### **3.1. 技术栈确认**

*   **编程语言**: Python 3.11+
*   **核心框架**: LangGraph, LangChain
*   **LLM 集成**: `langchain-google-genai` (用于集成 Gemini 2.5 Pro)
*   **接口层**: `python-telegram-bot` (一个成熟且功能强大的 Telegram Bot 框架)
*   **状态持久化**: `langchain_sqlite` (LangGraph 内置支持的 SQLite 检查点后端)
*   **HTTP 请求**: `requests` (用于调用未来的网页部署 API)
*   **环境管理**: `python-dotenv` (用于管理 API 密钥等环境变量)

#### **3.2. 数据库模式**

我们将使用 SQLite 进行状态持久化。在这种情况下，我们**不需要手动设计数据库表结构**。

LangGraph 的检查点机制 (`langchain_sqlite.SqliteSaver`) 会自动创建和管理所需的表，用于存储每个对话流程（线程）的完整状态快照、消息历史以及执行步骤，这完全满足了需求文档中对可靠性的要求。

#### **3.3. API 终点 / 交互接口**

系统的主要入口是 Telegram Bot，因此我们的“API”是用户与 Bot 之间的交互协议。

*   **启动命令**: `POST /<bot_token>/sendMessage`
    *   **用户输入**: `/start <课程主题>`
    *   **Bot 行为**:
        1.  为用户 (`chat_id`) 创建一个新的、唯一的流程实例 (`thread_id`)。
        2.  调用 LangGraph `app.invoke()`，传入初始状态。
        3.  图执行直到第一个中断点（生成初稿后），将结果发送给用户并请求审核。

*   **反馈接口**: `POST /<bot_token>/sendMessage`
    *   **用户输入**: 任何文本消息 (例如: "第二部分太长了，请缩短", 或 "同意")
    *   **Bot 行为**:
        1.  识别当前用户的 `thread_id`。
        2.  再次调用 LangGraph `app.invoke()`，传入包含用户反馈的更新状态。
        3.  LangGraph 从上次中断的地方继续执行。

#### **3.4. 核心组件/模块划分**

代码库将按功能进行模块化，以保证清晰性和可维护性。

1.  **`state.py`**: 定义 `CourseGenerationState` `TypedDict`。
2.  **`tools.py`**: 包含 `load_curriculum_framework()` 和 `deploy_webpage()` 等工具函数。
3.  **`nodes.py`**: 包含 LangGraph 工作流中所有节点的具体实现函数。
4.  **`graph.py`**: 系统的核心编排文件，负责构建 `StateGraph`、配置检查点并编译出最终的 `app` 对象。
5.  **`bot.py`**: 应用的主入口点，负责初始化 Telegram Bot 并与 `graph.py` 中的 `app` 进行交互。

#### **3.5. 项目文件结构**

```
.
├── .env                  # 存储 API 密钥和配置
├── .gitignore
├── requirements.txt      # 项目依赖
├── README.md
├── curriculum/
│   └── framework.md      # 课程框架模板
└── src/
    ├── __init__.py
    ├── state.py            # 状态定义 (CourseGenerationState)
    ├── tools.py            # 工具函数 (加载框架, 部署网页)
    ├── nodes.py            # Graph 节点函数
    ├── graph.py            # LangGraph 的定义与编译
    └── bot.py              # Telegram Bot 的主程序
```
